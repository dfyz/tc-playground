.version 8.7
.target sm_90a
.address_size 64

.visible .entry run_tc(
    .param .u64 mem_a_param,
    .param .u64 mem_b_param,
    .param .u64 a_desc_mask,
    .param .u64 b_desc_mask,
    .param .u64 mem_out_param
) {
    // ===VARIABLES===

    // Auxiliaries.
    .reg .b128 wide_data<4>;
    .reg .u64  tmp;
    .reg .u32  tid;

    // Output registers.
    .reg .f32 o<128>;

    // Global memory pointers to the inputs and the output.
    .reg .b64 mem_a;
    .reg .b64 mem_b;
    .reg .b64 mem_out;

    // Shared memory storage for the inputs.
    .shared .align 16 .b16 smem_a[16][64];
    .shared .align 16 .b16 smem_b[16][256];

    // Shared memory matrix descriptors.
    .reg .u64 a_desc;
    .reg .u64 b_desc;

    // ===LOGIC===

    mov.u32 tid, %tid.x;

    // Load the A matrix from global memory to the shared memory storage.
    // The host has already arranged the matrix elements properly,
    // so the device just needs to do a contiguous copy.
    // We have 16*64 = 1024 elements and 128 threads, so each thread
    // processes 8 elements using 16-byte loads/storse.
    ld.param.u64   tmp, [mem_a_param];
    mad.wide.u32   tmp, 16, tid, tmp;
    ld.global.b128 wide_data0, [tmp];

    mov.u64        tmp, smem_a;
    mad.wide.u32   tmp, 16, tid, tmp;
    st.shared.b128 [tmp], wide_data0;

    // Load the B matrix from global memory to the shared memory storage.
    // For B, we have 4 times more elements than A, so we have to perform 4
    // different 16-byte load/store pairs.
    ld.param.u64   tmp, [mem_b_param];
    mad.wide.u32   tmp, 64, tid, tmp;
    ld.global.b128 wide_data0, [tmp + 0*16];
    ld.global.b128 wide_data1, [tmp + 1*16];
    ld.global.b128 wide_data2, [tmp + 2*16];
    ld.global.b128 wide_data3, [tmp + 3*16];

    mov.u64        tmp, smem_b;
    mad.wide.u32   tmp, 64, tid, tmp;
    st.shared.b128 [tmp + 0*16], wide_data0;
    st.shared.b128 [tmp + 1*16], wide_data1;
    st.shared.b128 [tmp + 2*16], wide_data2;
    st.shared.b128 [tmp + 3*16], wide_data3;

    // We are done with writing to the shared memory.
    // According to 9.7.15.4, we now need to issue a fence to make these writes
    // visible to the async proxy, which performs the WGMMA.
    fence.proxy.async;

    // Write sentinel values (NaN) to all output registers.
    mov.f32   o0, 0Fffffffff; mov.f32   o1, 0Fffffffff; mov.f32   o2, 0Fffffffff; mov.f32   o3, 0Fffffffff;
    mov.f32   o4, 0Fffffffff; mov.f32   o5, 0Fffffffff; mov.f32   o6, 0Fffffffff; mov.f32   o7, 0Fffffffff;
    mov.f32   o8, 0Fffffffff; mov.f32   o9, 0Fffffffff; mov.f32  o10, 0Fffffffff; mov.f32  o11, 0Fffffffff;
    mov.f32  o12, 0Fffffffff; mov.f32  o13, 0Fffffffff; mov.f32  o14, 0Fffffffff; mov.f32  o15, 0Fffffffff;
    mov.f32  o16, 0Fffffffff; mov.f32  o17, 0Fffffffff; mov.f32  o18, 0Fffffffff; mov.f32  o19, 0Fffffffff;
    mov.f32  o20, 0Fffffffff; mov.f32  o21, 0Fffffffff; mov.f32  o22, 0Fffffffff; mov.f32  o23, 0Fffffffff;
    mov.f32  o24, 0Fffffffff; mov.f32  o25, 0Fffffffff; mov.f32  o26, 0Fffffffff; mov.f32  o27, 0Fffffffff;
    mov.f32  o28, 0Fffffffff; mov.f32  o29, 0Fffffffff; mov.f32  o30, 0Fffffffff; mov.f32  o31, 0Fffffffff;
    mov.f32  o32, 0Fffffffff; mov.f32  o33, 0Fffffffff; mov.f32  o34, 0Fffffffff; mov.f32  o35, 0Fffffffff;
    mov.f32  o36, 0Fffffffff; mov.f32  o37, 0Fffffffff; mov.f32  o38, 0Fffffffff; mov.f32  o39, 0Fffffffff;
    mov.f32  o40, 0Fffffffff; mov.f32  o41, 0Fffffffff; mov.f32  o42, 0Fffffffff; mov.f32  o43, 0Fffffffff;
    mov.f32  o44, 0Fffffffff; mov.f32  o45, 0Fffffffff; mov.f32  o46, 0Fffffffff; mov.f32  o47, 0Fffffffff;
    mov.f32  o48, 0Fffffffff; mov.f32  o49, 0Fffffffff; mov.f32  o50, 0Fffffffff; mov.f32  o51, 0Fffffffff;
    mov.f32  o52, 0Fffffffff; mov.f32  o53, 0Fffffffff; mov.f32  o54, 0Fffffffff; mov.f32  o55, 0Fffffffff;
    mov.f32  o56, 0Fffffffff; mov.f32  o57, 0Fffffffff; mov.f32  o58, 0Fffffffff; mov.f32  o59, 0Fffffffff;
    mov.f32  o60, 0Fffffffff; mov.f32  o61, 0Fffffffff; mov.f32  o62, 0Fffffffff; mov.f32  o63, 0Fffffffff;
    mov.f32  o64, 0Fffffffff; mov.f32  o65, 0Fffffffff; mov.f32  o66, 0Fffffffff; mov.f32  o67, 0Fffffffff;
    mov.f32  o68, 0Fffffffff; mov.f32  o69, 0Fffffffff; mov.f32  o70, 0Fffffffff; mov.f32  o71, 0Fffffffff;
    mov.f32  o72, 0Fffffffff; mov.f32  o73, 0Fffffffff; mov.f32  o74, 0Fffffffff; mov.f32  o75, 0Fffffffff;
    mov.f32  o76, 0Fffffffff; mov.f32  o77, 0Fffffffff; mov.f32  o78, 0Fffffffff; mov.f32  o79, 0Fffffffff;
    mov.f32  o80, 0Fffffffff; mov.f32  o81, 0Fffffffff; mov.f32  o82, 0Fffffffff; mov.f32  o83, 0Fffffffff;
    mov.f32  o84, 0Fffffffff; mov.f32  o85, 0Fffffffff; mov.f32  o86, 0Fffffffff; mov.f32  o87, 0Fffffffff;
    mov.f32  o88, 0Fffffffff; mov.f32  o89, 0Fffffffff; mov.f32  o90, 0Fffffffff; mov.f32  o91, 0Fffffffff;
    mov.f32  o92, 0Fffffffff; mov.f32  o93, 0Fffffffff; mov.f32  o94, 0Fffffffff; mov.f32  o95, 0Fffffffff;
    mov.f32  o96, 0Fffffffff; mov.f32  o97, 0Fffffffff; mov.f32  o98, 0Fffffffff; mov.f32  o99, 0Fffffffff;
    mov.f32 o100, 0Fffffffff; mov.f32 o101, 0Fffffffff; mov.f32 o102, 0Fffffffff; mov.f32 o103, 0Fffffffff;
    mov.f32 o104, 0Fffffffff; mov.f32 o105, 0Fffffffff; mov.f32 o106, 0Fffffffff; mov.f32 o107, 0Fffffffff;
    mov.f32 o108, 0Fffffffff; mov.f32 o109, 0Fffffffff; mov.f32 o110, 0Fffffffff; mov.f32 o111, 0Fffffffff;
    mov.f32 o112, 0Fffffffff; mov.f32 o113, 0Fffffffff; mov.f32 o114, 0Fffffffff; mov.f32 o115, 0Fffffffff;
    mov.f32 o116, 0Fffffffff; mov.f32 o117, 0Fffffffff; mov.f32 o118, 0Fffffffff; mov.f32 o119, 0Fffffffff;
    mov.f32 o120, 0Fffffffff; mov.f32 o121, 0Fffffffff; mov.f32 o122, 0Fffffffff; mov.f32 o123, 0Fffffffff;
    mov.f32 o124, 0Fffffffff; mov.f32 o125, 0Fffffffff; mov.f32 o126, 0Fffffffff; mov.f32 o127, 0Fffffffff;

    // We are done with writing the sentinel values to the output registers.
    // According to 9.7.15.7.1, now we need a fence to establish an ordering
    // between the sentinel stores and the actual WGMMA operation.
    wgmma.fence.sync.aligned;

    // Form the shared memory descriptors. Our canonical no-swizzle K-major (non-transposed) layout has:
    //   * the start of the matrix aligned to 16 bytes (encoded in the lowest 2 bytes)
    //   * LBO and SBO are pre-computed as a mask on the host
    //   * no swizzling (implicitly implied)
    // We don't explicity mask anything with `0x3FFFF`, since everything fits in 18 bits already.
    mov.u64      a_desc, smem_a;
    shr.u64      a_desc, a_desc, 4;
    ld.param.u64 tmp, [a_desc_mask];
    or.b64       a_desc, a_desc, tmp;

    mov.u64      b_desc, smem_b;
    shr.u64      b_desc, b_desc, 4;
    ld.param.u64 tmp, [b_desc_mask];
    or.b64       b_desc, b_desc, tmp;

    wgmma.mma_async.sync.aligned.m64n256k16.f32.bf16.bf16
        // A vector expression containing N/2 number of .f32 registers.
        {
              o0,   o1,   o2,   o3,   o4,   o5,   o6,   o7,   o8,   o9,  o10,  o11,  o12,  o13,  o14,  o15,
             o16,  o17,  o18,  o19,  o20,  o21,  o22,  o23,  o24,  o25,  o26,  o27,  o28,  o29,  o30,  o31,
             o32,  o33,  o34,  o35,  o36,  o37,  o38,  o39,  o40,  o41,  o42,  o43,  o44,  o45,  o46,  o47,
             o48,  o49,  o50,  o51,  o52,  o53,  o54,  o55,  o56,  o57,  o58,  o59,  o60,  o61,  o62,  o63,
             o64,  o65,  o66,  o67,  o68,  o69,  o70,  o71,  o72,  o73,  o74,  o75,  o76,  o77,  o78,  o79,
             o80,  o81,  o82,  o83,  o84,  o85,  o86,  o87,  o88,  o89,  o90,  o91,  o92,  o93,  o94,  o95,
             o96,  o97,  o98,  o99, o100, o101, o102, o103, o104, o105, o106, o107, o108, o109, o110, o111,
            o112, o113, o114, o115, o116, o117, o118, o119, o120, o121, o122, o123, o124, o125, o126, o127
        },
        a_desc,
        b_desc,
        0, // scale-d (overwrite the accumulator)
        1, // imm-scale-a (don't negate A)
        1, // imm-scale-b (don't negate B)
        0, // imm-trans-a (don't transpose A)
        0; // imm-trans-b (don't transpose B)

    wgmma.commit_group.sync.aligned;
    wgmma.wait_group.sync.aligned 0;

    // Each thread owns two rows and 256/4=64 columns, for a total of 128 4-byte registers.
    // We just dump them all to the output sorted by the thread id then the register name,
    // and let the host sort it out.
    ld.param.u64 tmp, [mem_out_param];
    mad.wide.u32 tmp, 512, tid, tmp;
    st.global.f32 [tmp +   0 * 4], o0;
    st.global.f32 [tmp +   1 * 4], o1;
    st.global.f32 [tmp +   2 * 4], o2;
    st.global.f32 [tmp +   3 * 4], o3;
    st.global.f32 [tmp +   4 * 4], o4;
    st.global.f32 [tmp +   5 * 4], o5;
    st.global.f32 [tmp +   6 * 4], o6;
    st.global.f32 [tmp +   7 * 4], o7;
    st.global.f32 [tmp +   8 * 4], o8;
    st.global.f32 [tmp +   9 * 4], o9;
    st.global.f32 [tmp +  10 * 4], o10;
    st.global.f32 [tmp +  11 * 4], o11;
    st.global.f32 [tmp +  12 * 4], o12;
    st.global.f32 [tmp +  13 * 4], o13;
    st.global.f32 [tmp +  14 * 4], o14;
    st.global.f32 [tmp +  15 * 4], o15;
    st.global.f32 [tmp +  16 * 4], o16;
    st.global.f32 [tmp +  17 * 4], o17;
    st.global.f32 [tmp +  18 * 4], o18;
    st.global.f32 [tmp +  19 * 4], o19;
    st.global.f32 [tmp +  20 * 4], o20;
    st.global.f32 [tmp +  21 * 4], o21;
    st.global.f32 [tmp +  22 * 4], o22;
    st.global.f32 [tmp +  23 * 4], o23;
    st.global.f32 [tmp +  24 * 4], o24;
    st.global.f32 [tmp +  25 * 4], o25;
    st.global.f32 [tmp +  26 * 4], o26;
    st.global.f32 [tmp +  27 * 4], o27;
    st.global.f32 [tmp +  28 * 4], o28;
    st.global.f32 [tmp +  29 * 4], o29;
    st.global.f32 [tmp +  30 * 4], o30;
    st.global.f32 [tmp +  31 * 4], o31;
    st.global.f32 [tmp +  32 * 4], o32;
    st.global.f32 [tmp +  33 * 4], o33;
    st.global.f32 [tmp +  34 * 4], o34;
    st.global.f32 [tmp +  35 * 4], o35;
    st.global.f32 [tmp +  36 * 4], o36;
    st.global.f32 [tmp +  37 * 4], o37;
    st.global.f32 [tmp +  38 * 4], o38;
    st.global.f32 [tmp +  39 * 4], o39;
    st.global.f32 [tmp +  40 * 4], o40;
    st.global.f32 [tmp +  41 * 4], o41;
    st.global.f32 [tmp +  42 * 4], o42;
    st.global.f32 [tmp +  43 * 4], o43;
    st.global.f32 [tmp +  44 * 4], o44;
    st.global.f32 [tmp +  45 * 4], o45;
    st.global.f32 [tmp +  46 * 4], o46;
    st.global.f32 [tmp +  47 * 4], o47;
    st.global.f32 [tmp +  48 * 4], o48;
    st.global.f32 [tmp +  49 * 4], o49;
    st.global.f32 [tmp +  50 * 4], o50;
    st.global.f32 [tmp +  51 * 4], o51;
    st.global.f32 [tmp +  52 * 4], o52;
    st.global.f32 [tmp +  53 * 4], o53;
    st.global.f32 [tmp +  54 * 4], o54;
    st.global.f32 [tmp +  55 * 4], o55;
    st.global.f32 [tmp +  56 * 4], o56;
    st.global.f32 [tmp +  57 * 4], o57;
    st.global.f32 [tmp +  58 * 4], o58;
    st.global.f32 [tmp +  59 * 4], o59;
    st.global.f32 [tmp +  60 * 4], o60;
    st.global.f32 [tmp +  61 * 4], o61;
    st.global.f32 [tmp +  62 * 4], o62;
    st.global.f32 [tmp +  63 * 4], o63;
    st.global.f32 [tmp +  64 * 4], o64;
    st.global.f32 [tmp +  65 * 4], o65;
    st.global.f32 [tmp +  66 * 4], o66;
    st.global.f32 [tmp +  67 * 4], o67;
    st.global.f32 [tmp +  68 * 4], o68;
    st.global.f32 [tmp +  69 * 4], o69;
    st.global.f32 [tmp +  70 * 4], o70;
    st.global.f32 [tmp +  71 * 4], o71;
    st.global.f32 [tmp +  72 * 4], o72;
    st.global.f32 [tmp +  73 * 4], o73;
    st.global.f32 [tmp +  74 * 4], o74;
    st.global.f32 [tmp +  75 * 4], o75;
    st.global.f32 [tmp +  76 * 4], o76;
    st.global.f32 [tmp +  77 * 4], o77;
    st.global.f32 [tmp +  78 * 4], o78;
    st.global.f32 [tmp +  79 * 4], o79;
    st.global.f32 [tmp +  80 * 4], o80;
    st.global.f32 [tmp +  81 * 4], o81;
    st.global.f32 [tmp +  82 * 4], o82;
    st.global.f32 [tmp +  83 * 4], o83;
    st.global.f32 [tmp +  84 * 4], o84;
    st.global.f32 [tmp +  85 * 4], o85;
    st.global.f32 [tmp +  86 * 4], o86;
    st.global.f32 [tmp +  87 * 4], o87;
    st.global.f32 [tmp +  88 * 4], o88;
    st.global.f32 [tmp +  89 * 4], o89;
    st.global.f32 [tmp +  90 * 4], o90;
    st.global.f32 [tmp +  91 * 4], o91;
    st.global.f32 [tmp +  92 * 4], o92;
    st.global.f32 [tmp +  93 * 4], o93;
    st.global.f32 [tmp +  94 * 4], o94;
    st.global.f32 [tmp +  95 * 4], o95;
    st.global.f32 [tmp +  96 * 4], o96;
    st.global.f32 [tmp +  97 * 4], o97;
    st.global.f32 [tmp +  98 * 4], o98;
    st.global.f32 [tmp +  99 * 4], o99;
    st.global.f32 [tmp + 100 * 4], o100;
    st.global.f32 [tmp + 101 * 4], o101;
    st.global.f32 [tmp + 102 * 4], o102;
    st.global.f32 [tmp + 103 * 4], o103;
    st.global.f32 [tmp + 104 * 4], o104;
    st.global.f32 [tmp + 105 * 4], o105;
    st.global.f32 [tmp + 106 * 4], o106;
    st.global.f32 [tmp + 107 * 4], o107;
    st.global.f32 [tmp + 108 * 4], o108;
    st.global.f32 [tmp + 109 * 4], o109;
    st.global.f32 [tmp + 110 * 4], o110;
    st.global.f32 [tmp + 111 * 4], o111;
    st.global.f32 [tmp + 112 * 4], o112;
    st.global.f32 [tmp + 113 * 4], o113;
    st.global.f32 [tmp + 114 * 4], o114;
    st.global.f32 [tmp + 115 * 4], o115;
    st.global.f32 [tmp + 116 * 4], o116;
    st.global.f32 [tmp + 117 * 4], o117;
    st.global.f32 [tmp + 118 * 4], o118;
    st.global.f32 [tmp + 119 * 4], o119;
    st.global.f32 [tmp + 120 * 4], o120;
    st.global.f32 [tmp + 121 * 4], o121;
    st.global.f32 [tmp + 122 * 4], o122;
    st.global.f32 [tmp + 123 * 4], o123;
    st.global.f32 [tmp + 124 * 4], o124;
    st.global.f32 [tmp + 125 * 4], o125;
    st.global.f32 [tmp + 126 * 4], o126;
    st.global.f32 [tmp + 127 * 4], o127;

    ret;
}
